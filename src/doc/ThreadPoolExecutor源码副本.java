package com.knowledge.collection.thread.threadpool;import java.security.AccessControlContext;import java.security.AccessController;import java.security.PrivilegedAction;import java.util.concurrent.*;import java.util.concurrent.locks.AbstractQueuedSynchronizer;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;import java.util.concurrent.atomic.AtomicInteger;import java.util.*;public class ThreadPoolExecutors extends AbstractExecutorService {    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));    private static final int COUNT_BITS = Integer.SIZE - 3;    private static final int CAPACITY   = (1 << COUNT_BITS) - 1;    // 该状态的线程池会接收新任务，也会处理在阻塞队列中等待处理的任务    private static final int RUNNING    = -1 << COUNT_BITS;    //该状态的线程池不会再接收新任务，但还会处理已经提交到阻塞队列中等待处理的任务    private static final int SHUTDOWN   =  0 << COUNT_BITS;    //该状态的线程池不会再接收新任务，不会处理在阻塞队列中等待的任务，而且还会中断正在运行的任务    private static final int STOP       =  1 << COUNT_BITS;    //所有任务都被终止了，workerCount为0，为此状态时还将调用terminated()方法    private static final int TIDYING    =  2 << COUNT_BITS;    //terminated()方法调用完成后变成此状态    private static final int TERMINATED =  3 << COUNT_BITS;    // Packing and unpacking ctl    private static int runStateOf(int c)     { return c & ~CAPACITY; }    private static int workerCountOf(int c)  { return c & CAPACITY; }    private static int ctlOf(int rs, int wc) { return rs | wc; }    /*     * Bit field accessors that don't require unpacking ctl.     * These depend on the bit layout and on workerCount being never negative.     */    private static boolean runStateLessThan(int c, int s) {        return c < s;    }    private static boolean runStateAtLeast(int c, int s) {        return c >= s;    }    private static boolean isRunning(int c) {        return c < SHUTDOWN;    }    private boolean compareAndIncrementWorkerCount(int expect) {        return ctl.compareAndSet(expect, expect + 1);    }    private boolean compareAndDecrementWorkerCount(int expect) {        return ctl.compareAndSet(expect, expect - 1);    }    private void decrementWorkerCount() {        do {} while (! compareAndDecrementWorkerCount(ctl.get()));    }    private final BlockingQueue<Runnable> workQueue;    private final ReentrantLock mainLock = new ReentrantLock();    private final HashSet<Worker> workers = new HashSet<Worker>();    private final Condition termination = mainLock.newCondition();    private int largestPoolSize;    private long completedTaskCount;    private volatile ThreadFactory threadFactory;    private volatile RejectedExecutionHandler handler;    private volatile long keepAliveTime;    private volatile boolean allowCoreThreadTimeOut;    private volatile int corePoolSize;    private volatile int maximumPoolSize;    private static final RejectedExecutionHandler defaultHandler =        new AbortPolicy();    private static final RuntimePermission shutdownPerm =        new RuntimePermission("modifyThread");    private final AccessControlContext acc;    private final class Worker        extends AbstractQueuedSynchronizer        implements Runnable    {        private static final long serialVersionUID = 6138294804551838833L;        /** Thread this worker is running in.  Null if factory fails. */        final Thread thread;        /** Initial task to run.  Possibly null. */        Runnable firstTask;        /** Per-thread task counter */        volatile long completedTasks;        Worker(Runnable firstTask) {            setState(-1); // inhibit interrupts until runWorker            this.firstTask = firstTask;            this.thread = getThreadFactory().newThread(this);        }        /** Delegates main run loop to outer runWorker  */        public void run() {            runWorker(this);        }        protected boolean isHeldExclusively() {            return getState() != 0;        }        protected boolean tryAcquire(int unused) {            if (compareAndSetState(0, 1)) {                setExclusiveOwnerThread(Thread.currentThread());                return true;            }            return false;        }        protected boolean tryRelease(int unused) {            setExclusiveOwnerThread(null);            setState(0);            return true;        }        public void lock()        { acquire(1); }        public boolean tryLock()  { return tryAcquire(1); }        public void unlock()      { release(1); }        public boolean isLocked() { return isHeldExclusively(); }        void interruptIfStarted() {            Thread t;            if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {                try {                    t.interrupt();                } catch (SecurityException ignore) {                }            }        }    }    private void advanceRunState(int targetState) {        for (;;) {            int c = ctl.get();            if (runStateAtLeast(c, targetState) ||                ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))                break;        }    }    final void tryTerminate() {        for (;;) {            int c = ctl.get();            if (isRunning(c) ||                runStateAtLeast(c, TIDYING) ||                (runStateOf(c) == SHUTDOWN && ! workQueue.isEmpty()))                return;            if (workerCountOf(c) != 0) { // Eligible to terminate                interruptIdleWorkers(ONLY_ONE);                return;            }            final ReentrantLock mainLock = this.mainLock;            mainLock.lock();            try {                if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {                    try {                        terminated();                    } finally {                        ctl.set(ctlOf(TERMINATED, 0));                        termination.signalAll();                    }                    return;                }            } finally {                mainLock.unlock();            }            // else retry on failed CAS        }    }    private void checkShutdownAccess() {        SecurityManager security = System.getSecurityManager();        if (security != null) {            security.checkPermission(shutdownPerm);            final ReentrantLock mainLock = this.mainLock;            mainLock.lock();            try {                for (Worker w : workers)                    security.checkAccess(w.thread);            } finally {                mainLock.unlock();            }        }    }    private void interruptWorkers() {        final ReentrantLock mainLock = this.mainLock;        mainLock.lock();        try {            for (Worker w : workers)                w.interruptIfStarted();        } finally {            mainLock.unlock();        }    }    private void interruptIdleWorkers(boolean onlyOne) {        final ReentrantLock mainLock = this.mainLock;        mainLock.lock();        try {            for (Worker w : workers) {                Thread t = w.thread;                if (!t.isInterrupted() && w.tryLock()) {                    try {                        t.interrupt();                    } catch (SecurityException ignore) {                    } finally {                        w.unlock();                    }                }                if (onlyOne)                    break;            }        } finally {            mainLock.unlock();        }    }    private void interruptIdleWorkers() {        interruptIdleWorkers(false);    }    private static final boolean ONLY_ONE = true;    final void reject(Runnable command) {        handler.rejectedExecution(command, this);    }    void onShutdown() {    }    final boolean isRunningOrShutdown(boolean shutdownOK) {        int rs = runStateOf(ctl.get());        return rs == RUNNING || (rs == SHUTDOWN && shutdownOK);    }    private List<Runnable> drainQueue() {        BlockingQueue<Runnable> q = workQueue;        ArrayList<Runnable> taskList = new ArrayList<Runnable>();        q.drainTo(taskList);        if (!q.isEmpty()) {            for (Runnable r : q.toArray(new Runnable[0])) {                if (q.remove(r))                    taskList.add(r);            }        }        return taskList;    }    private boolean addWorker(Runnable firstTask, boolean core) {        retry:        for (;;) {            int c = ctl.get();            int rs = runStateOf(c);             /*              *由上面的一些线程池状态常量值可知，running<shutdown<stop<tidying<terminated              *若rs>=shutdown,则表明线程池处于stop、tidying、terminated三种状态的一种              *若rs>=shutdown成立，则进行后面判断，              *1、线程池处于shutdown状态              *  1.1、firstTask不为null，则返回false，也即是线程池已经处于shutdown状态，还要添加新的线程，被直接驳回(拒绝)              *  1.2、firstTask为null              *     1.2.1、此时意味着线程池状态为shutdown状态，且first为null，若阻塞队列为空，则返回false              *2、线程处于大于shutdown的状态，则直接返回false             */            if (rs >= SHUTDOWN &&                ! (rs == SHUTDOWN &&                   firstTask == null &&                   ! workQueue.isEmpty()))                return false;            for (;;) {                //获取workCount                int wc = workerCountOf(c);                //workCount大于CAPACITY（内部临界值） return false                // 如果是核心线程  workCount大于 corePoolSize   return false                // 如果是非核心线程  workCount大于 maximumPoolSize   return false                if (wc >= CAPACITY ||                    wc >= (core ? corePoolSize : maximumPoolSize))                    return false;                //工作线程数+1 这里只是计数器加了一 并没真正创建线程                if (compareAndIncrementWorkerCount(c))                    //中断外循环 compareAndIncrementWorkerCount方法执行成功的情况下                    break retry;                c = ctl.get();  // Re-read ctl                //线程池状态是否发生变化                if (runStateOf(c) != rs)                    //如果没有发生变化则继续内循环，直到能正确的将工作线程数+1                    continue retry;                // else CAS failed due to workerCount change; retry inner loop            }        }        //接下来是真正的创建线程的步骤        boolean workerStarted = false;        boolean workerAdded = false;        //Worker是线程池的内部类        Worker w = null;        try {            w = new Worker(firstTask);            final Thread t = w.thread;            if (t != null) {                final ReentrantLock mainLock = this.mainLock;                mainLock.lock();                try {                    // Recheck while holding lock.                    // Back out on ThreadFactory failure or if                    // shut down before lock acquired.                    int rs = runStateOf(ctl.get());                    //检查状态  如果<SHUTDOWN  或者 =SHUTDOWN并且firstTask为空时,创建新线程                    //对应execute方法中addWorker(null, false);                    if (rs < SHUTDOWN ||                        (rs == SHUTDOWN && firstTask == null)) {                        //如果线程已经启动了 就跑出非法状态异常                        if (t.isAlive()) // precheck that t is startable                            throw new IllegalThreadStateException();                        workers.add(w);                        int s = workers.size();                        if (s > largestPoolSize)                            largestPoolSize = s;                        workerAdded = true;                    }                } finally {                    //不管是否添加了worker，最终都会释放锁                    mainLock.unlock();                }                //如果成功添加了，就启动线程                if (workerAdded) {                    //启动的是Worker的run方法，再                    /*                    Worker里面有一个Thread属性，并且将自己作为Runnable传给了自己的Thread属性，                    所以这里的start是启动自己的Run方法，而不是Task的Run方法，                    真正调用Task业务代码的逻辑是                    Worker.start->Worker.run->Task.run                    此时虽然Task虽然也是一个线程，但是不调用start方法 而是由Worker这个线程调用Task的run方法                    Worker的run方法是一个while循环 会判断自己拥有的task是否为空，如果为空则去任务队列里面获取                    如果任务队列获取不到了说明任务执行完了，进入空闲状态。                     */                    t.start();                    workerStarted = true;                }            }        } finally {            //如果Worker启动失败，则之前workCount+1 需要回滚            if (! workerStarted)                //这个方法里面进行-1操作                addWorkerFailed(w);        }        return workerStarted;    }    private void addWorkerFailed(Worker w) {        final ReentrantLock mainLock = this.mainLock;        mainLock.lock();        try {            if (w != null)                workers.remove(w);            decrementWorkerCount();            tryTerminate();        } finally {            mainLock.unlock();        }    }    private void processWorkerExit(Worker w, boolean completedAbruptly) {        if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted            decrementWorkerCount();        final ReentrantLock mainLock = this.mainLock;        mainLock.lock();        try {            completedTaskCount += w.completedTasks;            workers.remove(w);        } finally {            mainLock.unlock();        }        tryTerminate();        int c = ctl.get();        if (runStateLessThan(c, STOP)) {            if (!completedAbruptly) {                int min = allowCoreThreadTimeOut ? 0 : corePoolSize;                if (min == 0 && ! workQueue.isEmpty())                    min = 1;                if (workerCountOf(c) >= min)                    return; // replacement not needed            }            addWorker(null, false);        }    }    private Runnable getTask() {        boolean timedOut = false; // Did the last poll() time out?        for (;;) {            int c = ctl.get();            int rs = runStateOf(c);            // Check if queue empty only if necessary.            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {                decrementWorkerCount();                return null;            }            int wc = workerCountOf(c);            // Are workers subject to culling?            boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;            if ((wc > maximumPoolSize || (timed && timedOut))                && (wc > 1 || workQueue.isEmpty())) {                if (compareAndDecrementWorkerCount(c))                    return null;                continue;            }            try {                Runnable r = timed ?                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :                    workQueue.take();                if (r != null)                    return r;                timedOut = true;            } catch (InterruptedException retry) {                timedOut = false;            }        }    }    final void runWorker(Worker w) {        Thread wt = Thread.currentThread();        Runnable task = w.firstTask;        w.firstTask = null;        w.unlock(); // allow interrupts        boolean completedAbruptly = true;        try {            while (task != null || (task = getTask()) != null) {                w.lock();                // If pool is stopping, ensure thread is interrupted;                // if not, ensure thread is not interrupted.  This                // requires a recheck in second case to deal with                // shutdownNow race while clearing interrupt                if ((runStateAtLeast(ctl.get(), STOP) ||                     (Thread.interrupted() &&                      runStateAtLeast(ctl.get(), STOP))) &&                    !wt.isInterrupted())                    wt.interrupt();                try {                    beforeExecute(wt, task);                    Throwable thrown = null;                    try {                        task.run();                    } catch (RuntimeException x) {                        thrown = x; throw x;                    } catch (Error x) {                        thrown = x; throw x;                    } catch (Throwable x) {                        thrown = x; throw new Error(x);                    } finally {                        afterExecute(task, thrown);                    }                } finally {                    task = null;                    w.completedTasks++;                    w.unlock();                }            }            completedAbruptly = false;        } finally {            processWorkerExit(w, completedAbruptly);        }    }    public ThreadPoolExecutor(int corePoolSize,                              int maximumPoolSize,                              long keepAliveTime,                              TimeUnit unit,                              BlockingQueue<Runnable> workQueue) {        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,             Executors.defaultThreadFactory(), defaultHandler);    }    public ThreadPoolExecutor(int corePoolSize,                              int maximumPoolSize,                              long keepAliveTime,                              TimeUnit unit,                              BlockingQueue<Runnable> workQueue,                              ThreadFactory threadFactory) {        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,             threadFactory, defaultHandler);    }    public ThreadPoolExecutor(int corePoolSize,                              int maximumPoolSize,                              long keepAliveTime,                              TimeUnit unit,                              BlockingQueue<Runnable> workQueue,                              RejectedExecutionHandler handler) {        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,             Executors.defaultThreadFactory(), handler);    }    public ThreadPoolExecutor(int corePoolSize,                              int maximumPoolSize,                              long keepAliveTime,                              TimeUnit unit,                              BlockingQueue<Runnable> workQueue,                              ThreadFactory threadFactory,                              RejectedExecutionHandler handler) {        if (corePoolSize < 0 ||            maximumPoolSize <= 0 ||            maximumPoolSize < corePoolSize ||            keepAliveTime < 0)            throw new IllegalArgumentException();        if (workQueue == null || threadFactory == null || handler == null)            throw new NullPointerException();        this.acc = System.getSecurityManager() == null ?                null :                AccessController.getContext();        this.corePoolSize = corePoolSize;        this.maximumPoolSize = maximumPoolSize;        this.workQueue = workQueue;        this.keepAliveTime = unit.toNanos(keepAliveTime);        this.threadFactory = threadFactory;        this.handler = handler;    }    /**     * 在未来的某个时间执行给定的任务。该任务可以在新线程或现有池线程中执行。     * 如果任务无法提交执行，要么是因为这个执行器已经关闭，要么是因为它的容量已经达到.     * 任务由当前的RejectedExecutionHandler处理。     * @param command     */    public void execute(Runnable command) {        //如果为任务为null 抛出NPE        if (command == null)            throw new NullPointerException();        //获取计数器        int c = ctl.get();        //case1 : 当前线程数少于核心线程数        if (workerCountOf(c) < corePoolSize) {            //调用创建线程的方法，并将线程设置为核心线程            if (addWorker(command, true))                //成功则返回                return;            //不成功则再次获取计数器            c = ctl.get();        }        /*        case2:核心线程满了，但是队列没满        如果线程池还处于运行状态 并且往任务队列里面放入新的任务成功        ，说明此时核心线程满了，但是队列没满         */        if (isRunning(c) && workQueue.offer(command)) {            int recheck = ctl.get();            /*            此处有两个判断条件            1.isRunning（true 还能接收和处理新的任务/ false 不接收任务）            2.从队列移除结果（成功/失败）            有4种结果            ----------------------------------------------------            isRunning |! isRunning|  isRemove  |  result  |   remark              true          false        短路      false       只要线程池还在running ，不会拒绝新任务              false         true         true      true       线程池的状态无法接收新的task，移除该task，执行拒绝策略              false         true         false     false      线程池的状态无法接收新的task，移除该task失败（说明任务开始运行）                                                              说明刚好有线程空闲下来了（消耗了这个任务），             */            if (! isRunning(recheck) && remove(command))                //拒绝该任务                reject(command);            //如果当前work线程数量为0            else if (workerCountOf(recheck) == 0)                //新建一个非核心线程 maxPoolSize                // first参数为空 是因为只创建线程（待命），不分配任务  上面无法删除的任务已经被之前空闲下来的线程拿去跑了                addWorker(null, false);        }        //如果addWorker失败 说明线程数量达到了maxPoolSize，执行拒绝策略        //case3:核心线程满了，并且队列也满了        else if (!addWorker(command, false))            reject(command);    }    public void shutdown() {        final ReentrantLock mainLock = this.mainLock;        mainLock.lock();        try {            checkShutdownAccess();            advanceRunState(SHUTDOWN);            interruptIdleWorkers();            onShutdown(); // hook for ScheduledThreadPoolExecutor        } finally {            mainLock.unlock();        }        tryTerminate();    }    public List<Runnable> shutdownNow() {        List<Runnable> tasks;        final ReentrantLock mainLock = this.mainLock;        mainLock.lock();        try {            checkShutdownAccess();            advanceRunState(STOP);            interruptWorkers();            tasks = drainQueue();        } finally {            mainLock.unlock();        }        tryTerminate();        return tasks;    }    public boolean isShutdown() {        return ! isRunning(ctl.get());    }    public boolean isTerminating() {        int c = ctl.get();        return ! isRunning(c) && runStateLessThan(c, TERMINATED);    }    public boolean isTerminated() {        return runStateAtLeast(ctl.get(), TERMINATED);    }    public boolean awaitTermination(long timeout, TimeUnit unit)        throws InterruptedException {        long nanos = unit.toNanos(timeout);        final ReentrantLock mainLock = this.mainLock;        mainLock.lock();        try {            for (;;) {                if (runStateAtLeast(ctl.get(), TERMINATED))                    return true;                if (nanos <= 0)                    return false;                nanos = termination.awaitNanos(nanos);            }        } finally {            mainLock.unlock();        }    }    /**     * Invokes {@code shutdown} when this executor is no longer     * referenced and it has no threads.     */    protected void finalize() {        SecurityManager sm = System.getSecurityManager();        if (sm == null || acc == null) {            shutdown();        } else {            PrivilegedAction<Void> pa = () -> { shutdown(); return null; };            AccessController.doPrivileged(pa, acc);        }    }    public void setThreadFactory(ThreadFactory threadFactory) {        if (threadFactory == null)            throw new NullPointerException();        this.threadFactory = threadFactory;    }    public ThreadFactory getThreadFactory() {        return threadFactory;    }    public void setRejectedExecutionHandler(RejectedExecutionHandler handler) {        if (handler == null)            throw new NullPointerException();        this.handler = handler;    }    public RejectedExecutionHandler getRejectedExecutionHandler() {        return handler;    }    public void setCorePoolSize(int corePoolSize) {        if (corePoolSize < 0)            throw new IllegalArgumentException();        int delta = corePoolSize - this.corePoolSize;        this.corePoolSize = corePoolSize;        if (workerCountOf(ctl.get()) > corePoolSize)            interruptIdleWorkers();        else if (delta > 0) {            // We don't really know how many new threads are "needed".            // As a heuristic, prestart enough new workers (up to new            // core size) to handle the current number of tasks in            // queue, but stop if queue becomes empty while doing so.            int k = Math.min(delta, workQueue.size());            while (k-- > 0 && addWorker(null, true)) {                if (workQueue.isEmpty())                    break;            }        }    }    public int getCorePoolSize() {        return corePoolSize;    }    public boolean prestartCoreThread() {        return workerCountOf(ctl.get()) < corePoolSize &&            addWorker(null, true);    }    void ensurePrestart() {        int wc = workerCountOf(ctl.get());        if (wc < corePoolSize)            addWorker(null, true);        else if (wc == 0)            addWorker(null, false);    }    public int prestartAllCoreThreads() {        int n = 0;        while (addWorker(null, true))            ++n;        return n;    }    public boolean allowsCoreThreadTimeOut() {        return allowCoreThreadTimeOut;    }    public void allowCoreThreadTimeOut(boolean value) {        if (value && keepAliveTime <= 0)            throw new IllegalArgumentException("Core threads must have nonzero keep alive times");        if (value != allowCoreThreadTimeOut) {            allowCoreThreadTimeOut = value;            if (value)                interruptIdleWorkers();        }    }    public void setMaximumPoolSize(int maximumPoolSize) {        if (maximumPoolSize <= 0 || maximumPoolSize < corePoolSize)            throw new IllegalArgumentException();        this.maximumPoolSize = maximumPoolSize;        if (workerCountOf(ctl.get()) > maximumPoolSize)            interruptIdleWorkers();    }    public int getMaximumPoolSize() {        return maximumPoolSize;    }    public void setKeepAliveTime(long time, TimeUnit unit) {        if (time < 0)            throw new IllegalArgumentException();        if (time == 0 && allowsCoreThreadTimeOut())            throw new IllegalArgumentException("Core threads must have nonzero keep alive times");        long keepAliveTime = unit.toNanos(time);        long delta = keepAliveTime - this.keepAliveTime;        this.keepAliveTime = keepAliveTime;        if (delta < 0)            interruptIdleWorkers();    }    public long getKeepAliveTime(TimeUnit unit) {        return unit.convert(keepAliveTime, TimeUnit.NANOSECONDS);    }    public boolean remove(Runnable task) {        boolean removed = workQueue.remove(task);        tryTerminate(); // In case SHUTDOWN and now empty        return removed;    }    public void purge() {        final BlockingQueue<Runnable> q = workQueue;        try {            Iterator<Runnable> it = q.iterator();            while (it.hasNext()) {                Runnable r = it.next();                if (r instanceof Future<?> && ((Future<?>)r).isCancelled())                    it.remove();            }        } catch (ConcurrentModificationException fallThrough) {            // Take slow path if we encounter interference during traversal.            // Make copy for traversal and call remove for cancelled entries.            // The slow path is more likely to be O(N*N).            for (Object r : q.toArray())                if (r instanceof Future<?> && ((Future<?>)r).isCancelled())                    q.remove(r);        }        tryTerminate(); // In case SHUTDOWN and now empty    }    /* Statistics */    public int getPoolSize() {        final ReentrantLock mainLock = this.mainLock;        mainLock.lock();        try {            // Remove rare and surprising possibility of            // isTerminated() && getPoolSize() > 0            return runStateAtLeast(ctl.get(), TIDYING) ? 0                : workers.size();        } finally {            mainLock.unlock();        }    }    public int getActiveCount() {        final ReentrantLock mainLock = this.mainLock;        mainLock.lock();        try {            int n = 0;            for (Worker w : workers)                if (w.isLocked())                    ++n;            return n;        } finally {            mainLock.unlock();        }    }    public int getLargestPoolSize() {        final ReentrantLock mainLock = this.mainLock;        mainLock.lock();        try {            return largestPoolSize;        } finally {            mainLock.unlock();        }    }    public long getTaskCount() {        final ReentrantLock mainLock = this.mainLock;        mainLock.lock();        try {            long n = completedTaskCount;            for (Worker w : workers) {                n += w.completedTasks;                if (w.isLocked())                    ++n;            }            return n + workQueue.size();        } finally {            mainLock.unlock();        }    }    public long getCompletedTaskCount() {        final ReentrantLock mainLock = this.mainLock;        mainLock.lock();        try {            long n = completedTaskCount;            for (Worker w : workers)                n += w.completedTasks;            return n;        } finally {            mainLock.unlock();        }    }    public String toString() {        long ncompleted;        int nworkers, nactive;        final ReentrantLock mainLock = this.mainLock;        mainLock.lock();        try {            ncompleted = completedTaskCount;            nactive = 0;            nworkers = workers.size();            for (Worker w : workers) {                ncompleted += w.completedTasks;                if (w.isLocked())                    ++nactive;            }        } finally {            mainLock.unlock();        }        int c = ctl.get();        String rs = (runStateLessThan(c, SHUTDOWN) ? "Running" :                     (runStateAtLeast(c, TERMINATED) ? "Terminated" :                      "Shutting down"));        return super.toString() +            "[" + rs +            ", pool size = " + nworkers +            ", active threads = " + nactive +            ", queued tasks = " + workQueue.size() +            ", completed tasks = " + ncompleted +            "]";    }    protected void beforeExecute(Thread t, Runnable r) { }    protected void afterExecute(Runnable r, Throwable t) { }    protected void terminated() { }    public static class CallerRunsPolicy implements RejectedExecutionHandler {        /**         * Creates a {@code CallerRunsPolicy}.         */        public CallerRunsPolicy() { }        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {            if (!e.isShutdown()) {                r.run();            }        }    }    public static class AbortPolicy implements RejectedExecutionHandler {        public AbortPolicy() { }        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {            throw new RejectedExecutionException("Task " + r.toString() +                                                 " rejected from " +                                                 e.toString());        }    }    public static class DiscardPolicy implements RejectedExecutionHandler {        public DiscardPolicy() { }        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {        }    }    public static class DiscardOldestPolicy implements RejectedExecutionHandler {        public DiscardOldestPolicy() { }        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {            if (!e.isShutdown()) {                e.getQueue().poll();                e.execute(r);            }        }    }}